#!/usr/bin/env python
#
# Copyright (C) 2020 Prayush Kumar
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""Perform calibration runs for ENIGMA model using another BBH model """

import time
__itime__ = time.time()

import os
import sys
import h5py
import numpy as np
import argparse
import logging
from multiprocessing import Pool
import pandas as pd

from gwnrtools import __version__
from gwnrtools.utils import make_padded_frequency_series
from gwnrtools.stats.priors import (__all_cbc_parameters__, default_bbh_params)
from gwnrtools.stats.samplers import (
    get_emcee_ensemble_sampler, write_output_from_emcee_sampler)
from gwnrtools.stats.sampling import OneDRandom
from gwnrtools.stats.enigma_utils import (
    log_prior_enigma, log_likelihood_enigma, log_prob_enigma,
    __log_prob_funcs__,
    __order_of_sampled_params__, __ranges_of_sampled_params__)

from pycbc.psd import from_string

############################################################
# command line usage
parser = argparse.ArgumentParser(usage=__file__ + " [--options]",
                                 description=__doc__)
parser.add_argument("--version", action="version", version=__version__,
                    help="Prints version information.")
parser.add_argument("--verbose", action="store_true", default=False,
                    help="Print logging messages.")
parser.add_argument("--debug", action="store_true", default=False,
                    help="Print debugging messages.")

# workflow options
parser.add_argument("--job-id", type=str, required=True)
parser.add_argument("--param-file", type=str, required=True,
                    help="Input parameter file")
parser.add_argument("--enigma-tag", type=str, required=True,
                    help="TAG that uniquely identifies the fit to be used.")
parser.add_argument("--min-omega-attach", type=float, default=0.01,
                    help="Lower limit for dimless attachment freq.")
parser.add_argument("--max-omega-attach", type=float, default=0.1,
                    help="Upper limit for dimless attachment freq.")

parser.add_argument("--choices-pn-order", type=str, required=False,
                    default='6,7,8,9,10,11,12',
                    help="Comma-separated list of PN orders to try")

parser.add_argument("--signal-approx", type=str, required=False,
                    default='SEOBNRv4_ROM',
                    help="Signal approximant to test against (FD)")

parser.add_argument("--num-samplers", type=int, default=32,
                    help="No of MCMC walkers")
parser.add_argument("--num-mcmc-steps", type=int, default=100,
                    help="No of MCMC steps per walker")
parser.add_argument("--sample-rate", type=int, default=4096,
                    help="Sampling rate for wave gen and matches")
parser.add_argument("--time-length", type=int, default=32,
                    help="Expected max duration of waves")

parser.add_argument("--use-dilation-map-match",
                    action="store_true", default=False,
                    help="use a nonlinear dilating map for match")
# parallelization options
parser.add_argument("--num-processes", type=int, default=2,
                    help="No of Multiprocessing processes")

# output options
parser.add_argument("--output-prefix", type=str, required=False,
                    default='results/matches_vs_',
                    help="Input parameter file")

# parse command line
opts = parser.parse_args()

logging.getLogger().setLevel(logging.INFO)

if opts.enigma_tag not in __ranges_of_sampled_params__:
    raise IOError("FIT TAG: {} not recognized for ranges".format(opts.enigma_tag))
if opts.enigma_tag not in __order_of_sampled_params__:
    raise IOError("FIT TAG: {} not recognized for order".format(opts.enigma_tag))
if opts.enigma_tag not in __log_prob_funcs__:
    raise IOError("FIT TAG: {} not recognized for logprob funcs".format(opts.enigma_tag))
############################################################
# inputs
user_inputs = {}

user_inputs['job_id'] = opts.job_id
user_inputs['param_file'] = opts.param_file
user_inputs['signal_approx'] = opts.signal_approx
user_inputs['output_prefix'] = opts.output_prefix + \
    '{0}'.format(opts.signal_approx)
# user_inputs['use_dilation_map_match'] = opts.use_dilation_map_match

# MCMC params
user_inputs['num_samplers'] = opts.num_samplers
user_inputs['num_steps'] = opts.num_mcmc_steps

# Filtering params
user_inputs['sample_rate'] = opts.sample_rate
user_inputs['time_length'] = opts.time_length

user_inputs['delta_t'] = 1. / user_inputs['sample_rate']
user_inputs['delta_f'] = 1. / user_inputs['time_length']
N = user_inputs['sample_rate'] * user_inputs['time_length']
n = N / 2 + 1

user_inputs = pd.DataFrame.from_dict(
    {i: (user_inputs[i],) for i in user_inputs})
############################################################
# Setup
# Note: the dataframe populated below is meant to provide sampling
# details for any and all parameters that we might want to sample.
# This does **not** provide an eshaustive list of sampled parameters.
# That is to be provided by the version of ENIGMA fit, and is defined
# in `gwnrtools.stats.enigma_utils`.
all_sampling_params = {}
all_inputs = {}
with h5py.File(user_inputs['param_file'][0], 'r') as fin:
    for j_id in fin:
        if opts.verbose:
            logging.info("Preparing calc: {}".format(j_id))

        sampling_params = default_bbh_params.copy()
        inputs = user_inputs.copy()
        # Insert (a1-b4) calibration parameters as columns here
        ranges_of_sampled_params_for_this_fit = __ranges_of_sampled_params__[opts.enigma_tag]
        for p in ranges_of_sampled_params_for_this_fit:
            if p in sampling_params:
                continue
            r = ranges_of_sampled_params_for_this_fit[p]
            if len(r) == 2: # interpret this as an interval
                sampling_params[p] = ('uniform', r)
            elif len(r) > 2: # interpret this as discrete choices
                sampling_params[p] = ('choices', r)
        # Insert omega_attach as columns here
        sampling_params['omega_attach'] = ('dependent', [opts.min_omega_attach, opts.max_omega_attach])
        # Insert ranges for CBC parameters from input file
        for p in fin[j_id]:
            if p in __all_cbc_parameters__:
                d = fin[j_id][p][()]
                if len(d) == 1:
                    sampling_params[p] = ('fixed', np.array([d]).flatten())
                elif len(d) == 2:
                    sampling_params[p] = ('uniform', np.array(d).flatten())
                elif len(d) > 2:
                    sampling_params[p] = ('choices', np.array(d).flatten())
            else:
                inputs[p] = fin[j_id][p][()]
        # Insert a list of sampled parameters
        sampling_params['sampler_params'] = (
            'fixed', __order_of_sampled_params__[opts.enigma_tag])
        inputs['sampler_params'] = (
            __order_of_sampled_params__[opts.enigma_tag],)
        all_sampling_params[j_id] = sampling_params
        all_inputs[j_id] = inputs
        if opts.debug:
            for c in inputs:
                print(inputs[c])
# FIXME: pandas.Panel is deprecated. Replace with MultiIndex.
sampling_panel = pd.Panel(all_sampling_params)
sampling_inputs = pd.Panel(all_inputs)

logging.info(".. input parameters read.")

############################################################
if opts.verbose:
    logging.info("Starting job: {}".format(inputs.job_id[0]))
    logging.info("Will read from: {}".format(inputs.param_file[0]))
    logging.info("Will compute matches against {}".format(
        inputs.signal_approx[0]))
    logging.info("Will sample omega_att: [{0}, {1}]".format(
        *sampling_params.omega_attach.range))
    logging.info("Will sample PN order from: {}".format(
        sampling_params.PNO.range))
    logging.info("Will take {} MCMC steps per sampler".format(
        inputs.num_steps[0]))
    logging.info("Will use {} samplers".format(inputs.num_samplers[0]))
    logging.info("Will write output with prefix: {}".format(
        inputs.output_prefix[0]))
    logging.info("Will filter at {0}Hz with maxT = {1}secs".format(
        inputs.sample_rate[0], inputs.time_length[0]))


############################################################
# Functions and classes
def output_file(prefix, job_id, idx):
    return prefix + '{0}_{1:06d}.dat'.format(job_id, idx)


def hdf_backend_file(out_file):
    return out_file.replace('.dat', '.ckpt.hdf')


############################################################
# Create and run samplers, store output
try:
    __my_pool__ = Pool(processes=opts.num_processes)
except:
    __my_pool__ = None

samplers = {}
old_f_lower = -1

# Loop over all unique MCMC jobs
num_mcmc = len(sampling_panel)

for idx, j_id in enumerate(sampling_panel):
    sampling_params = sampling_panel[j_id]
    if opts.verbose:
        logging.info("All params: {}".format(sampling_params.columns))
    inputs = sampling_inputs[j_id]
    try:
        f_lower = float(inputs['f_lower'][0])
        df = inputs['delta_f'][0]
        dt = inputs['delta_t'][0]
        sample_rate = 1. / dt
        N = int(1. / dt / df)
        n = N / 2 + 1

        if opts.verbose:
            logging.info(
                "\n\n ... starting MCMC for setting {0}/{1}: f_low={2:.0f}".format(idx,
                                                                                   len(inputs[inputs.keys()[
                                                                                       0]]),
                                                                                   f_lower))

        if f_lower != old_f_lower:
            # from global settings
            psd = from_string(inputs['psd'][0], n, df, f_lower)
            psd = make_padded_frequency_series(psd, N, df)
            old_f_lower = f_lower

        # RUN THE SAMPLER
        hdf_backend = hdf_backend_file(output_file(inputs['output_prefix'][0],
                                                   inputs['job_id'][0],
                                                   idx))
        logging.info(
            "... will checkpoint the MCMC sampler to {}".format(hdf_backend))

        logging.info("... initializing the MCMC sampler and burning-in")
        samplers[j_id] = \
            get_emcee_ensemble_sampler(__log_prob_funcs__[opts.enigma_tag],
                                       sampling_params[list(
                                           inputs['sampler_params'][0])],
                                       [inputs.iloc[0],
                                        f_lower, sampling_params, psd,
                                        opts.enigma_tag, # TAG for the fit to use
                                        False,  # dilation_map
                                        opts.verbose],
                                       kwargs={},
                                       backend_hdf=hdf_backend,
                                       nwalkers=inputs.num_samplers[0],
                                       burn_in=100,
                                       pool=__my_pool__,
                                       verbose=opts.verbose,
                                       debug=opts.debug)

        logging.info(
            "... Running the MCMC sampler for {0} steps".format(inputs.num_steps[0]))
        s, state, p0 = samplers[j_id]
        try:
            s.run_mcmc(None, inputs.num_steps[0])
        except ValueError:
            s.run_mcmc(p0, inputs.num_steps[0])

        # WRite output from the sampler
        logging.info("... Writing output now..")
        write_output_from_emcee_sampler(output_file(inputs['output_prefix'][0],
                                                    inputs['job_id'][0],
                                                    idx),
                                        s,
                                        sampling_params[sampling_params['sampler_params'].range])

        logging.info("... Written output!")
        # Early stop
        if idx >= 1e9:
            break
    except:
        logging.error("Error in parameter set[{0}]: f_low={1:.0f}".format(j_id,
                                                                          f_lower))
        raise
__my_pool__.close()
__my_pool__.terminate()
logging.info(" .. MCMC samples written.")
logging.info("All Done in {0} seconds".format(time.time() - __itime__))
